using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace ScriptSchedulerApp
{
    public static class TaskWrapper
    {
        /// <summary>
        /// Creates a VBS wrapper script to run scripts completely hidden
        /// </summary>
        public static string CreateVBSWrapper(
            string taskName,
            string scriptPath,
            string scriptType,
            string wrapperDir,
            string workingDir,
            string scriptArgs,
            string logDir)
        {
            try
            {
                // Ensure directories exist
                if (!Directory.Exists(wrapperDir))
                    Directory.CreateDirectory(wrapperDir);
                
                if (!Directory.Exists(logDir))
                    Directory.CreateDirectory(logDir);

                // Create wrapper name from task name
                string wrapperName = SanitizeFilename(taskName);
                string vbsPath = Path.Combine(wrapperDir, $"{wrapperName}.vbs");
                
                // Build the target command using GetHiddenExecutionCommand to avoid duplicate logic
                var (executable, arguments) = GetHiddenExecutionCommand(scriptPath, scriptType, scriptArgs);
                string targetCommand = $"\"{executable}\" {arguments}";

                // Create VBS script content that uses WScript.Shell to run command hidden
                var sb = new StringBuilder();
                sb.AppendLine("' Script hidden execution wrapper");
                sb.AppendLine("' Generated by ScriptSchedulerApp");
                sb.AppendLine();
                sb.AppendLine("Option Explicit");
                
                // Main variables
                sb.AppendLine("Dim WshShell, fso, objNet");
                sb.AppendLine("Dim logPath, logFile, logFolder, logStream");
                sb.AppendLine("Dim exitCode, errMsg");
                sb.AppendLine();
                
                // Initialize objects
                sb.AppendLine("' Initialize objects");
                sb.AppendLine("Set WshShell = CreateObject(\"WScript.Shell\")");
                sb.AppendLine("Set fso = CreateObject(\"Scripting.FileSystemObject\")");
                sb.AppendLine("Set objNet = CreateObject(\"WScript.Network\")");
                sb.AppendLine();
                
                // Configure log paths - use simple single-quoted strings for clarity
                sb.AppendLine("' Configure network log path");
                sb.AppendLine("logFolder = \"\\\\192.168.1.238\\System Administration Folder\\Scheduled Scripts\\TaskSchedulerLogs\"");
                
                // Generate log filename with timestamp
                sb.AppendLine("' Generate log filename with timestamp");
                sb.AppendLine($"logFile = \"{wrapperName}_\" & Year(Now) & Right(\"0\" & Month(Now), 2) & Right(\"0\" & Day(Now), 2) & \"_\" & Right(\"0\" & Hour(Now), 2) & Right(\"0\" & Minute(Now), 2) & Right(\"0\" & Second(Now), 2) & \".log\"");
                sb.AppendLine("logPath = logFolder & \"\\\" & logFile");
                sb.AppendLine();
                
                // Set up error handling
                sb.AppendLine("' Configure error handling");
                sb.AppendLine("On Error Resume Next");
                sb.AppendLine();
                
                // Access and create network log directory if needed
                sb.AppendLine("' Check network log folder");
                sb.AppendLine("If Not fso.FolderExists(logFolder) Then");
                sb.AppendLine("    ' Try to create the network log folder");
                sb.AppendLine("    ' Method 1: Direct FSO creation");
                sb.AppendLine("    fso.CreateFolder(logFolder)");
                sb.AppendLine("    ");
                sb.AppendLine("    If Err.Number <> 0 Then");
                sb.AppendLine("        Err.Clear");
                sb.AppendLine("        ' Method 2: Use CMD to create folder");
                sb.AppendLine("        WshShell.Run \"cmd.exe /c mkdir \"\"\" & logFolder & \"\"\"\", 0, True");
                sb.AppendLine("    End If");
                sb.AppendLine("End If");
                sb.AppendLine();
                
                // Double-check folder exists before proceeding
                sb.AppendLine("' Verify log folder exists");
                sb.AppendLine("If Not fso.FolderExists(logFolder) Then");
                sb.AppendLine("    errMsg = \"Cannot access or create log folder: \" & logFolder & \" (\" & Err.Number & \": \" & Err.Description & \")\"");
                sb.AppendLine("    WScript.Echo errMsg");
                sb.AppendLine("    WScript.Quit 1");
                sb.AppendLine("End If");
                sb.AppendLine();
                
                // Create log file
                sb.AppendLine("' Create log file");
                sb.AppendLine("Set logStream = fso.CreateTextFile(logPath, True)");
                sb.AppendLine("If Err.Number <> 0 Then");
                sb.AppendLine("    errMsg = \"Cannot create log file: \" & logPath & \" (\" & Err.Number & \": \" & Err.Description & \")\"");
                sb.AppendLine("    WScript.Echo errMsg");
                sb.AppendLine("    WScript.Quit 1");
                sb.AppendLine("End If");
                sb.AppendLine();
                
                // Logging function
                sb.AppendLine("' Log helper function");
                sb.AppendLine("Sub WriteLog(message)");
                sb.AppendLine("    On Error Resume Next");
                sb.AppendLine("    logStream.WriteLine Now & \" - \" & message");
                sb.AppendLine("    If Err.Number <> 0 Then");
                sb.AppendLine("        WScript.Echo \"Error writing to log: \" & Err.Description");
                sb.AppendLine("        Err.Clear");
                sb.AppendLine("    End If");
                sb.AppendLine("End Sub");
                sb.AppendLine();
                
                // Turn off error handling for main execution
                sb.AppendLine("On Error Goto 0");
                sb.AppendLine();
                
                // Log execution start
                sb.AppendLine("' Log execution details");
                sb.AppendLine("WriteLog \"*** Script execution started ***\"");
                sb.AppendLine("WriteLog \"Computer: \" & objNet.ComputerName");
                sb.AppendLine("WriteLog \"Username: \" & objNet.UserName");
                sb.AppendLine("WriteLog \"Domain: \" & objNet.UserDomain");
                sb.AppendLine($"WriteLog \"Script path: {scriptPath.Replace("\"", "\"\"")}\"");
                sb.AppendLine($"WriteLog \"Working directory: {workingDir.Replace("\"", "\"\"")}\"");
                sb.AppendLine($"WriteLog \"Command: {targetCommand.Replace("\"", "\"\"")}\"");
                sb.AppendLine();
                
                // Run the command with window hidden (0) and wait for completion (True)
                sb.AppendLine("' Execute the script with window completely hidden");
                sb.AppendLine("On Error Resume Next");
                sb.AppendLine($"exitCode = WshShell.Run(\"{targetCommand.Replace("\"", "\"\"")}\", 0, True)");
                sb.AppendLine("If Err.Number <> 0 Then");
                sb.AppendLine("    WriteLog \"ERROR: Command execution failed: \" & Err.Description & \" (\" & Err.Number & \")\"");
                sb.AppendLine("    Err.Clear");
                sb.AppendLine("Else");
                sb.AppendLine("    WriteLog \"Script completed with exit code: \" & exitCode");
                sb.AppendLine("End If");
                sb.AppendLine();
                
                // Cleanup and exit
                sb.AppendLine("' Cleanup and exit");
                sb.AppendLine("WriteLog \"*** Script execution completed ***\"");
                sb.AppendLine("logStream.Close");
                sb.AppendLine("Set logStream = Nothing");
                sb.AppendLine("Set fso = Nothing");
                sb.AppendLine("Set WshShell = Nothing");
                sb.AppendLine("Set objNet = Nothing");
                sb.AppendLine("WScript.Quit exitCode");
                
                // Write the VBS script to file using UTF-8 *without* BOM
                // The BOM can sometimes cause issues with VBScript hosts
                var utf8WithoutBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
                File.WriteAllText(vbsPath, sb.ToString(), utf8WithoutBom);
                
                Debug.WriteLine($"Created VBS wrapper (UTF-8 without BOM) at {vbsPath}");
                return vbsPath;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error creating VBS wrapper: {ex.Message}");
                throw new Exception($"Failed to create VBS wrapper: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// Gets the command-line arguments for executing a script hidden
        /// </summary>
        public static (string executable, string arguments) GetHiddenExecutionCommand(
            string scriptPath,
            string scriptType,
            string args)
        {
            switch (scriptType)
            {
                case "PowerShell":
                    // PowerShell scripts should run hidden with execution policy bypass
                    return ("powershell.exe", $"-WindowStyle Hidden -NoProfile -ExecutionPolicy Bypass -File \"{scriptPath}\" {args}");
                
                case "Python":
                    // Use pythonw.exe for hidden execution
                    return ("pythonw.exe", $"\"{scriptPath}\" {args}");
                
                case "Batch":
                    // For batch files, we can just pass args directly
                    return ("cmd.exe", $"/c \"{scriptPath}\" {args}");
                
                case "VBScript":
                case "JavaScript":
                    // Return script arguments
                    return ("wscript.exe", $"\"{scriptPath}\" {args}");
                
                default:
                    // For unknown script types, just pass args directly
                    return (scriptPath, args);
            }
        }

        /// <summary>
        /// Runs a script completely hidden using Windows Script Host (equivalent to WScript.Shell.Run)
        /// </summary>
        public static void RunScriptCompletelyHidden(string scriptPath, string scriptType, string args, string workingDir)
        {
            try
            {
                // Create Windows Script Host Shell object
                Type shellType = Type.GetTypeFromProgID("WScript.Shell");
                dynamic shell = Activator.CreateInstance(shellType);
                
                // Use GetHiddenExecutionCommand to avoid duplicate logic
                var (executable, arguments) = GetHiddenExecutionCommand(scriptPath, scriptType, args);
                string command = $"\"{executable}\" {arguments}";
                
                // Set working directory if provided
                if (!string.IsNullOrEmpty(workingDir))
                {
                    shell.CurrentDirectory = workingDir;
                }
                
                // Run the command completely hidden
                // 0 = hide window, false = don't wait for completion
                shell.Run(command, 0, false);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error running script hidden: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Sanitizes a filename by removing invalid characters
        /// </summary>
        public static string SanitizeFilename(string filename)
        {
            if (string.IsNullOrEmpty(filename))
                return "Wrapper";

            // Replace invalid characters with underscores
            char[] invalidChars = Path.GetInvalidFileNameChars();
            foreach (char c in invalidChars)
            {
                filename = filename.Replace(c, '_');
            }

            // Ensure filename is not too long
            if (filename.Length > 50)
            {
                filename = filename.Substring(0, 50);
            }

            return filename;
        }
    }
}